# @centraverse/api

This package contains the backend of Centraverse. It's a [GraphQL](https://graphql.org/) API written in [TypeScript](https://www.typescriptlang.org/) with [Pothos](https://pothos-graphql.dev/).

## Overview of the technologies used

This part of the README aims to give a quick overview of the technologies used in this project. If you're already familiar with them, you can skip this section.

### TypeScript

While JavaScript is a great and powerful language, it falls short is some areas that makes it unsuitable for large projects. Among other things, [TypeScript](https://www.typescriptlang.org/) adds types to JavaScript:

```ts
// In JavaScript you can do this:
let age = 20;
age = '20';

// In TypeScript you can't:
let age = 20;
age = '20';
// (x) Type 'string' is not assignable to type 'number'.

// Declare an object shape:
interface User {
  name: string;
  email: string;
}

const sendMail = (user: User) => {};

// This works:
sendMail({ name: 'John', email: 'john@example.com' });

// This doesn't:
sendMail('john@example.com');
// (x) Argument of type 'string' is not assignable to parameter of type 'User'.
```

Furthermore, **with great typing comes great autocompletion.**

### GraphQL

[GraphQL](https://graphql.org/) is a query language designed for APIs. The server exposes a schema that describes the data available and the client can query it.

Here is a simplified version of Centraverse's schema:

```graphql
# Declare a type:
type User {
  firstName: String # Primitive string type
  lastName: String
  email: String
}

type Article {
  title: String
  # Declare a relationship:
  author: User # An article has an author of type User
}

# Root query type:
type Query {
  homepage: [Article] # The homepage is a list of articles
}
```

You can get the complete schema by running `yarn build && cat build/schema.graphql` in this folder.

A client can then query the API:

```graphql
query {
  homepage {
    title
    author {
      # Only query the fields you need:
      firstName
      lastName
    }
  }
}
```

And the server will return a JSON object with exactly what the client asked:

```json
{
  "homepage": [
    {
      "title": "Hello world",
      "author": { "firstName": "John", "lastName": "Doe" }
    },
    {
      "title": "Welcome to Centraverse",
      "author": { "firstName": "Jane", "lastName": "Doe" }
    }
  ]
}
```

### Prisma

[Prisma](https://www.prisma.io/) is an ORM for various database engines, we use it to query a PostgreSQL database. Prisma shines by its type safety:

```ts
const articles = await prisma.article.findMany({
  where: { published: true },
  include: { author: true },
});
// articles is of type Array<{title: string; ...; author: {firstName: string; ...}}>
```

### Pothos

[Pothos](https://pothos-graphql.dev/) is a schema-first GraphQL engine. It works very well with TypeScript and Prisma, making it a breeze to expose data from the database.

```ts
// Declare a GraphQL-type:
export const ArticleType = builder.prismaNode('Article', {
  id: { field: 'id' },
  fields: (t) => ({
    // Expose a database field:
    title: t.exposeString('title'),
    // Pothos and Prisma take care of the relationship:
    author: t.relation('author'),
  }),
});

// Declare a query field:
builder.queryField('article', (t) =>
  t.prismaField({
    type: ArticleType,
    // This field is queried with an ID:
    args: { id: t.arg.id() },
    // `resolve` produces the API response:
    resolve: async (query, _, { id }) =>
      prisma.article.findUniqueOrThrow({ ...query, where: { id } }),
  })
);
```

This allows the client to query the API like this:

```graphql
query {
  # Get the article with ID 1:
  article(id: "1") {
    title
    # Get the author of the article:
    author {
      firstName
      lastName
    }
  }
}
```

## Architecture

- **build/**: the build output, generated by `yarn build`
- **prisma/**
  - **migrations/**: [the database migrations](https://www.prisma.io/docs/guides/database/developing-with-prisma-migrate); migrations allow incremental changes to the database schema
  - **schema.prisma**: the Prisma schema that describes the database structure
- **src/**
  - **objects/**: GraphQL operations grouped by object type
  - **services/**: business logic grouped by purpose
  - **index.ts**: starts the server

## Adding a new resource

You need to do a few things:

1. Define its model in `prisma/schema.prisma`
   1. Make sure that the line immediately after the model declaration (`model MyName {`) defines the id of the resource
   1. Use `@default(dbgenerated("nanoid('prefix:')"))` where `prefix` is a short prefix corresponding to your resource's name as the id's default value
   1. Execute `node scripts/update-id-prefix-to-typename-map.js` to update the ID prefix to typename map in `src/builder.ts`.
1. Define the object in `src/objects/my-resource-name.ts`
1. Define its fields, using:
   - a `prismaNode` if you need paging support
   - a `prismaObject` otherwise
1. Define its queries, each resource should have at least:
   - a single-resource query, that you get by uid or id if the
     resource has no uid
   - a "list" query, tha gets all of the resources
   - if it makes sense, a "search" query that searches fuzzily.
1. Define its mutations, each resource should have at least:
   - an "upsert" mutation, that takes all of the data and an optinal `id` argument. If `id` is null, the resource will be created with the data, else, the resource identified by `id` will be updated.
   - a deletion mutation, that takes the `id` of the resource and returns `true` if the resource was deleted and `false` otherwise.
1. Make sure to get permissions right.

   - Each query and mutation should define an `authScope` method that makes sure the logged-in user has the right to get, list, update, create or delete the requested resource.

1. Register the resource to the schema by importing it in `schema.ts`

1. TEST that your API works using the GraphiQL endpoint (`localhost:4000/graphql` in your browser), setting the `Authorization` header to various Bearer tokens that represent:
   - An admin user
   - Every possible case dependending on the permissions of the resource (for example, managers of an event for the `EventManager` resource)
   - A regular user
   - A logged-out user (i.e. no `Authorization` header)
